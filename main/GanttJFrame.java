/*
 * ExperimentalJFrame.java
 *
 * Created on March 5, 2010, 10:14 PM
 */

package main;

import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Dimension;

import java.awt.Point;
import java.awt.Rectangle;
import java.awt.Shape;
import java.awt.geom.Rectangle2D;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;

import java.util.Calendar;
import java.util.Date;
import java.util.GregorianCalendar;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.jfree.chart.ChartFactory;
import org.jfree.chart.ChartPanel;
import org.jfree.chart.JFreeChart;
import org.jfree.chart.plot.CategoryPlot;
import org.jfree.data.category.CategoryDataset;

import javax.swing.JFrame;

import org.jfree.chart.axis.DateAxis;
import org.jfree.chart.labels.CategoryItemLabelGenerator;
import org.jfree.chart.labels.ItemLabelAnchor;
import org.jfree.chart.labels.ItemLabelPosition;
import org.jfree.chart.plot.ValueMarker;
import org.jfree.chart.renderer.category.BarPainter;
import org.jfree.chart.renderer.category.StandardBarPainter;
import org.jfree.data.category.IntervalCategoryDataset;
import org.jfree.data.gantt.GanttCategoryDataset;
import org.jfree.data.gantt.Task;
import org.jfree.data.gantt.TaskSeries;
import org.jfree.data.gantt.TaskSeriesCollection;
import org.jfree.data.time.SimpleTimePeriod;
import org.jfree.ui.Layer;
import org.jfree.ui.RectangleEdge;
import org.jfree.ui.TextAnchor;

/**
 * GanttJFrame is instantiated as a single static object from the Main class.
 * This class provides the GUI for the Gantt chart.
 * @author  Dan
 */
public class GanttJFrame extends JFrame {
    
    
//    OperationList operationList = new OperationList();
//    ResourceList resourceList = new ResourceList();
//    PatientList patientList = new PatientList();
//    Schedule schedule;

    private Scheduler scheduler;
    private ParameterProcessor parameterProcessor;

    private Schedule schedule;

    private Date startDate;
    private int startMin;
    private Date endDate;
    private int clickedOperationID = -1; //this is the operation that user has clicked on the chart.
    
    private int year=0;
    private int month=0;
    private int day=0;
    private int hour=0;
    private int min=0;

    private ChartPanel chartPanelInit;
    private DeleteOperationDialog deleteOperationDialog = new DeleteOperationDialog();
    private AddOperationDialog addOperationDialog = new AddOperationDialog(this, true);
    

//    /**
//     * Creates new form ExperimentalJFrame with a schedule and initializes JFrame
//     */
//    GanttJFrame(Schedule schedule, Scheduler scheduler) {
//        this.schedule = schedule;
//        this.scheduler = scheduler;
//        this.parameterProcessor = scheduler.getParameterProcessor();
//
//        this.operationList = schedule.getOperationList();
//        this.patientList = schedule.getPatientList();
//        this.resourceList = schedule.getResourceList();
//
//        Calendar cal = new GregorianCalendar();
//        // Calendar to Date Conversion
//        this.year = cal.get(Calendar.YEAR);
//        this.month = cal.get(Calendar.MONTH);
//        this.day = cal.get(Calendar.DATE);
//        this.hour = cal.get(Calendar.HOUR_OF_DAY);
//        this.min = cal.get(Calendar.MINUTE);
//        this.year = year-1900;
//
////        chartPanelInit = generateChartPanelContent();
//        initComponents();
//    }
    
    
    /**
     * Creates new JFrame without schedule (therefore cannot initialize.)
     * Used in tandem with the "setSchedule" method which initializes the Jframe.
     */
    GanttJFrame(){
        
    }

    GanttJFrame(ParameterProcessor parameterProcessor, Schedule schedule, Scheduler scheduler){
        this.parameterProcessor = parameterProcessor;
        this.schedule = schedule;
        this.scheduler = scheduler;

        Calendar cal = new GregorianCalendar();
        // Calendar to Date Conversion
        year = cal.get(Calendar.YEAR)-1900;

//        month = cal.get(Calendar.MONTH);
//        day = cal.get(Calendar.DATE);
        
        month = scheduler.getCurrentMonth();
        day = scheduler.getCurrentDate();

//        hour = cal.get(Calendar.HOUR_OF_DAY);
//        min = cal.get(Calendar.MINUTE);
        hour = scheduler.getCurrentHour();
        min = scheduler.getCurrentMinute();
//        year = year-1900;

        System.out.println("GanttJFrame CONSTRUCTOR HAS currents of: "+year+"/"+month+"/"+day);

        initComponents();
        this.setLocationRelativeTo(null);
    }
    
    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jPanel2 = new javax.swing.JPanel();
        jScrollPane1 = new javax.swing.JScrollPane();
        jTextArea1 = new javax.swing.JTextArea();
        editOperationButton = new javax.swing.JButton();
        deleteOperationButton = new javax.swing.JButton();
        addOperationButton = new javax.swing.JButton();
        jLabel1 = new javax.swing.JLabel();
        addTestCasePatientButton = new javax.swing.JButton();
        jScrollPane2 = new javax.swing.JScrollPane();
        dataset = createDatasetByPatient();
        //        IntervalCategoryDataset dataset = createDatasetByResource();
        chart = createChart((IntervalCategoryDataset) dataset);
        //JFreeChart chart = generateChartPanelContent(schedule);
        ChartPanel chartPanelInit = new ChartPanel(chart);
        //        DanChartMouseListener chartMouseListener = new DanChartMouseListener();
        chartPanelInit.addMouseListener(chartMouseListener);
        chartPanelInit.addChartMouseListener(chartMouseListener);
        chartPanelInit.setPreferredSize(new Dimension(1000,700));
        chartPanel = new javax.swing.JPanel();

        setTitle("Gantt Output");

        jTextArea1.setEditable(false);
        jTextArea1.setBackground(new java.awt.Color(240, 240, 240));
        jTextArea1.setColumns(20);
        jTextArea1.setRows(5);
        jTextArea1.setText("Select a task");
        jScrollPane1.setViewportView(jTextArea1);

        editOperationButton.setText("Edit..");

        deleteOperationButton.setText("Delete");
        deleteOperationButton.setEnabled(false);
        deleteOperationButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                deleteOperationButtonActionPerformed(evt);
            }
        });

        addOperationButton.setText("Add..");
        addOperationButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                addOperationButtonActionPerformed(evt);
            }
        });

        jLabel1.setText("Task Control");

        addTestCasePatientButton.setText("AddTestCasePatient");
        addTestCasePatientButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                addTestCasePatientButtonActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout jPanel2Layout = new javax.swing.GroupLayout(jPanel2);
        jPanel2.setLayout(jPanel2Layout);
        jPanel2Layout.setHorizontalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel2Layout.createSequentialGroup()
                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 235, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(jLabel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(addOperationButton, 0, 0, Short.MAX_VALUE)
                    .addComponent(editOperationButton, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(deleteOperationButton, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 126, Short.MAX_VALUE)
                .addComponent(addTestCasePatientButton)
                .addContainerGap())
        );
        jPanel2Layout.setVerticalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel2Layout.createSequentialGroup()
                .addContainerGap(31, Short.MAX_VALUE)
                .addComponent(jLabel1)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(addOperationButton)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(editOperationButton)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(deleteOperationButton)
                    .addComponent(addTestCasePatientButton))
                .addContainerGap())
            .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 143, Short.MAX_VALUE)
        );

        chartPanel = chartPanelInit;
        chartPanel.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                chartMouseClicked(evt);
            }
        });

        javax.swing.GroupLayout chartPanelLayout = new javax.swing.GroupLayout(chartPanel);
        chartPanel.setLayout(chartPanelLayout);
        chartPanelLayout.setHorizontalGroup(
            chartPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 569, Short.MAX_VALUE)
        );
        chartPanelLayout.setVerticalGroup(
            chartPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 178, Short.MAX_VALUE)
        );

        jScrollPane2.setPreferredSize(new Dimension(1020,620));

        jScrollPane2.setViewportView(chartPanel);
        //MouseListener[] mouseListener = chartPanelInit.getMouseListeners();
        //MouseListener chartMouseListener = mouseListener[0];
        //System.out.println(chartMouseListener.toString());

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jPanel2, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(7, 7, 7)
                .addComponent(jPanel2, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

private void chartMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_chartMouseClicked
    clickedCategory = chartMouseListener.getCategory();
    if((clickedCategory != null)&&(clickedCategory.matches("") == false)){
        deleteOperationButton.setEnabled(true);
        jTextArea1.setText("");
        CategoryPlot plot =  (CategoryPlot) chart.getPlot();
        ChartPanel cPCast = (ChartPanel) chartPanel;  //Cast chartPanel to ChartPanel type in order to use class-specific method (it is treated by the GUI renderer as a JPanel
        Rectangle2D plotRect = cPCast.getChartRenderingInfo().getPlotInfo().getDataArea();

        DateAxis rangeAxis = (DateAxis) plot.getRangeAxis();
    //    System.out.println("plotRect X, Y: "+plotRect.getX()+", "+plotRect.getY());
    //    System.out.println(plotRect.getBounds2D().getMinX()+","+plotRect.getBounds2D().getMaxX()+","+plotRect.getBounds2D().getMinY()+","+plotRect.getBounds2D().getMaxY());
    //    System.out.println("RANGE AXIS LB: "+ rangeAxis.getRange().getLowerBound());
    //    System.out.println("RANGE AXIS UB: "+ rangeAxis.getRange().getUpperBound());

        long timeInMillis = (long) rangeAxis.java2DToValue(chartMouseListener.getStartCoordinateDouble(), plotRect, RectangleEdge.TOP);
    //    System.out.println("MouseX: "+ rangeAxis.java2DToValue(chartMouseListener.getStartCoordinateDouble(), plotRect, RectangleEdge.TOP));
    //    System.out.println("RANGE AXIS UB: "+ rangeAxis.getRange().getUpperBound());
    //    String time = String.format("%d days, %d min, %d sec", TimeUnit.MILLISECONDS.toDays(timeInMillis), TimeUnit.MILLISECONDS.toMinutes(timeInMillis), TimeUnit.MILLISECONDS.toSeconds(timeInMillis) - TimeUnit.MINUTES.toSeconds(TimeUnit.MILLISECONDS.toMinutes(timeInMillis)));
        GregorianCalendar entityCalendar = new GregorianCalendar();
        entityCalendar.setTimeInMillis(timeInMillis);
        Date entityTime = entityCalendar.getTime();

        GregorianCalendar realTimeCalendar = new GregorianCalendar();
        Date realTime = realTimeCalendar.getTime();
//        System.out.println("realtime is: "+realTime);

        int entityMinute = entityTime.getMinutes()+1; //stores the int value of minutes from t=0=beginning of schedule
    //    if (entityMinute < 10){
    //        String entityMinuteString = "0".concat(Integer.toString(entityMinute));
    //    }
    //    else{
    //        String entityMinuteString = Integer.toString(entityMinute);
    //    }
    //    
        int entityHour = entityTime.getHours();

        System.out.println("entityTime: "+entityTime.getMonth()+"/"+entityTime.getDate() + ", " + entityTime.getHours() + ":"+ entityMinute);

        /**
         * @TODO:
         * TODO's for this 'for' block:
         * 1. Change to accurately capture the PatientID from Category-- will require some data structure design with database.
         * 2. change 2nd if to search in integer domain rather than date domain to span 2 or more different hours
         */
        int strID = (int) Integer.valueOf(clickedCategory.substring(0, clickedCategory.indexOf(" ")));
        for (int o = 0; o < parameterProcessor.getOperationList().size(); o++){
            if(parameterProcessor.getOperationList().get(o).getPatientID() == strID ){
    //            System.out.println("opST: "+(parameterProcessor.getOperationList().get(o).getStartTime()+schedule.getScheduleStartMin()));
    //            System.out.println("opSM: "+parameterProcessor.getOperationList().get(o).getStartMinute());
    //            System.out.println("time:"+entityMinute);
    //            if (parameterProcessor.getOperationList().get(o).getStartTime()+schedule.getScheduleStartMin() == entityMinute){
                if (parameterProcessor.getOperationList().get(o).getStartMinute() == entityMinute && parameterProcessor.getOperationList().get(o).getStartHour() == entityHour){

                    clickedOperationID = parameterProcessor.getOperationList().get(o).getID();
                    int clickedResourceID = parameterProcessor.getOperationList().get(o).getResourceID();
                    int clickedPatientID = parameterProcessor.getOperationList().get(o).getPatientID();
                    System.out.println("ResourceID: "+ clickedResourceID);
                    jTextArea1.append("Operation: " +clickedOperationID+"\n\r");
                    jTextArea1.append("Resource: " +clickedResourceID+"\n\r");
                    jTextArea1.append("Patient: " +clickedPatientID+"\n\r");

                    String startMinuteString = Integer.toString(parameterProcessor.getOperationList().get(o).getStartMinute());
                    if (parameterProcessor.getOperationList().get(o).getStartMinute() < 10){
                        startMinuteString = "0".concat(startMinuteString);
                    }
                    String endMinuteString = Integer.toString(parameterProcessor.getOperationList().get(o).getEndMinute());
                    if (parameterProcessor.getOperationList().get(o).getEndMinute() < 10){
                        endMinuteString = "0".concat(endMinuteString);
                    }

                    jTextArea1.append("Starts: "+parameterProcessor.getOperationList().get(o).getStartHour() + ":"+ startMinuteString +"\n\r");
                    jTextArea1.append("Ends: "+parameterProcessor.getOperationList().get(o).getEndHour() + ":"+ endMinuteString+"\n\r");
                }
            }
            else{
    //            continue;
            }
        }
    }else{
        jTextArea1.setText("Select a Task");
        deleteOperationButton.setEnabled(false);
    }
}//GEN-LAST:event_chartMouseClicked

/**
 * Brings up the AlterOperationDialog for deleting a selected operation
 * @param evt
 */
    @SuppressWarnings("static-access")
private void deleteOperationButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_deleteOperationButtonActionPerformed

        deleteOperationDialog.setConfirmChangeWithReschedule(false);
        deleteOperationDialog.setConfirmChangeWithoutReschedule(false);
        deleteOperationDialog.setModal(true);
        deleteOperationDialog.setVisible(true);
        deleteOperationDialog.setAlwaysOnTop(true);
        
        /**
         * -HOLD FOR USER INPUT (DIALOG IS MODAL)
         * -ON CLOSE OF DIALOG, CONTINUE..
         */

        if (deleteOperationDialog.isConfirmChangeWithReschedule() == true) {
            
            //make the change and reschedule
            System.out.println("Change with reschedule.");
            if(clickedOperationID != -1){
//                schedule.getOperationList().removeByID(selectedOperation);
//                selectedOperation = -1; //reset to -1 to avoid index bound exception
//                this.setSchedule(schedule);
//                
//                ChartPanel chartPanelInit = generateChartPanelContent();
//                chartPanel = chartPanelInit;
//              
//                chartPanel.validate();
//                chartPanel.repaint();
////                this.validate();
//////                this.repaint();
////                this.pack();
            }else{}
            
        } else if (deleteOperationDialog.isConfirmChangeWithoutReschedule() == true) {
            
            //make the change without rescheduling        
            System.out.println("Change without reschedule.");
            if(clickedOperationID != -1){
                String clickedOperationIDString = ((Integer) clickedOperationID).toString();
                
                /**
                 * @TODO: this will definitely have to be changed...
                 */
                String patientIDString = ((Integer) parameterProcessor.getOperationList().getByID(clickedOperationID).getPatientID()).toString().concat(" Patient");
                System.out.println(patientIDString);
                
//                schedule.getOperationList().remove(clickedOperationID);
                ChartPanel theChartPanel = (ChartPanel) chartPanel;
                TaskSeriesCollection tSC = (TaskSeriesCollection) theChartPanel.getChart().getCategoryPlot().getDataset();
                System.out.println("clickedOperationIDString: "+ clickedOperationIDString);
                
                
                String subtaskDescription = "";
                int subtaskIndex = -1;
                for(int i =0 ; i < tSC.getSeries(0).get(patientIDString).getSubtaskCount(); i++){
                    if(tSC.getSeries(0).get(patientIDString).getSubtask(i).getDescription().matches(clickedOperationIDString)){
                        subtaskDescription = tSC.getSeries(0).get(patientIDString).getSubtask(i).getDescription();
                        subtaskIndex = i;
                        break;
                    }
                }
                
                tSC.getSeries(0).get(patientIDString).removeSubtask(tSC.getSeries(0).get(patientIDString).getSubtask(subtaskIndex));
                parameterProcessor.getOperationList().removeByID(clickedOperationID);
//                scheduler.setOperationList(parameterProcessor.getOperationList());
//                scheduler.getParameterProcessor().setOperationList(parameterProcessor.getOperationList());

                theChartPanel.getChart().fireChartChanged();
                chartPanel = theChartPanel;

                clickedOperationID = -1;
                
            }else{}
        
        } else{
            System.out.println("Change either failed or was cancelled by user.");
        }

        this.toFront();
        chartPanel.validate();

}//GEN-LAST:event_deleteOperationButtonActionPerformed

private void addOperationButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_addOperationButtonActionPerformed
    addOperationDialog.setVisible(true);
}//GEN-LAST:event_addOperationButtonActionPerformed

private void addTestCasePatientButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_addTestCasePatientButtonActionPerformed
    

}//GEN-LAST:event_addTestCasePatientButtonActionPerformed

    /**
     * Returns dataset grouped by Patient.
     *
     * @return The dataset.
     */
    private GanttCategoryDataset createDatasetByPatient() {
        
        final TaskSeriesCollection collection = new TaskSeriesCollection();
        TaskSeries seriesOne = new TaskSeries("Series One");
        /**Adding data in this series**/
        
       //=============DISPLAY GANTT BY PATIENT==========
        PatientList.sortByID(parameterProcessor.getPatientList());

        for(Object patObj : parameterProcessor.getPatientList()){
            Patient patient = (Patient) patObj;
            String patientName = patient.getName();

            int minStartDate;
                int minStartHour;
                int minStartMinute;
                long minStartEpochTime = Long.MAX_VALUE;

                int maxEndDate;
                int maxEndHour;
                int maxEndMinute;
                long maxEndEpochTime = 0;


                

                for(Object opObj : parameterProcessor.getOperationList()){
                    Operation operation = (Operation) opObj;
                    if(operation.getPatientID() == patient.getID()){
                        patient.getRequiredOpList().add(operation);
                    }
                }

//            System.out.println("patient.getOpList is.. "+patient.getOperationList().isEmpty());
            if(patient.getOperationList().isEmpty() == false){
                
                for(Object opObj : parameterProcessor.getOperationList()){
                    Operation operation = (Operation) opObj;

                    if(operation.getPatientID() == patient.getID()){
        //                int checkStartDate = parameterProcessor.getOperationList().getByIDs(operation.getResourceID(), patient.getID()).getStartDate();
        //                int checkStartHour = parameterProcessor.getOperationList().getByIDs(operation.getResourceID(), patient.getID()).getStartHour();
        //                int checkStartMinute = parameterProcessor.getOperationList().getByIDs(operation.getResourceID(), patient.getID()).getStartMinute();
                        long checkStartEpochTime = parameterProcessor.getOperationList().getByIDs(operation.getResourceID(), patient.getID()).getStartEpochTime();
//                        System.out.println(parameterProcessor.getOperationList().getByIDs(operation.getResourceID(), patient.getID()).getStartYear());

        //                int checkEndDate = parameterProcessor.getOperationList().getByIDs(operation.getResourceID(), patient.getID()).getEndDate();
        //                int checkEndHour = parameterProcessor.getOperationList().getByIDs(operation.getResourceID(), patient.getID()).getEndHour();
        //                int checkEndMinute = parameterProcessor.getOperationList().getByIDs(operation.getResourceID(), patient.getID()).getEndMinute();
                        long checkEndEpochTime = parameterProcessor.getOperationList().getByIDs(operation.getResourceID(), patient.getID()).getEndEpochTime();

                        if(checkStartEpochTime < minStartEpochTime){
                            minStartEpochTime = checkStartEpochTime;
                        }
                        if (checkEndEpochTime > maxEndEpochTime){
                            maxEndEpochTime = checkEndEpochTime;
                        }
                    }
                }
            }else{
                Calendar calendar = new GregorianCalendar();
                calendar.set(Calendar.YEAR, calendar.get(Calendar.YEAR)-1900);
                calendar.set(Calendar.DATE, scheduler.getCurrentDate());
                calendar.set(Calendar.HOUR, scheduler.getScheduleStartHour());
                calendar.set(Calendar.MINUTE, scheduler.getScheduleStartMin());

                minStartEpochTime = scheduler.getScheduleStartEpochTime();
                maxEndEpochTime = scheduler.getScheduleStartEpochTime();
            }

            
            
            
            startDate = new Date(minStartEpochTime);
//            System.out.println("patient: "+ patient.getID()+ " starts at: "+startDate);
            
            endDate = new Date(maxEndEpochTime);
//            System.out.println("patient: "+ patient.getID()+ " ends at: "+endDate);
//            Task mainTask = new Task(patientName, new SimpleTimePeriod(startDate, endDate));
            Task mainTask = new Task(patientName, startDate, endDate);

            seriesOne.add(mainTask);

            for (Object operationObj : parameterProcessor.getOperationList()){
                Operation currentOperation = (Operation) operationObj;

                if(currentOperation.getPatientID() != patient.getID()){
                }
                else{
                    int currentOperationID = currentOperation.getID();
                    Integer operationID = (Integer) currentOperationID;

                    String operationIDString = operationID.toString();

                    int startSub = currentOperation.getStartTime();
                    Date startDateSub = new Date(year, month, currentOperation.getStartDate(), currentOperation.getStartHour(), currentOperation.getStartMinute());
//                    System.out.println("op: "+ currentOperation.getID()+ " starts at: "+startDateSub);

                    int endSub = currentOperation.getEndTime();
                    Date endDateSub = new Date(year, month, currentOperation.getEndDate(), currentOperation.getEndHour(), currentOperation.getEndMinute());

//                    Task subtask = new Task(operationIDString, new SimpleTimePeriod(startDateSub, endDateSub));
                    Task subtask = new Task(operationIDString, startDateSub, endDateSub);
                    mainTask.addSubtask(subtask);
                }
            }
        }

	/**
	* Adding the series to the collection
	* Holds actual Dates.
        */
       
	collection.add(seriesOne); 
	return collection;
    }
 
    /**
     * Creates the chart
     * @param the dataset from which to build the chart.
     * @return The chart.
     */
    private JFreeChart createChart(IntervalCategoryDataset dataset) {
        
        chart = ChartFactory.createGanttChart(
            "EUH ED Schedule by Patient",       // chart title
            "Patient",               // domain axis label
            "Time",
            dataset,    //dataset
            false,          //Legend
            true,          //Tooltips
            true           //URLs
            );
        
        CategoryPlot plot = chart.getCategoryPlot();
        plot.setRangePannable(true);

        Date plotStartDate = new Date();
//        plotStartDate.setMonth(0);
//        plotStartDate.setDate(0);
        plotStartDate.setHours(0);
        plotStartDate.setMinutes(0);

        Date plotEndDate = new Date();
        plotEndDate.setDate(plotEndDate.getDate()+1);
//        plotEndDate.setMonth(12);
//        plotEndDate.setDate(0);
        plotEndDate.setHours(6);
        plotEndDate.setMinutes(0);
//        plotEndDate.setMonth(6);


        DanGanttRenderer renderer = new DanGanttRenderer(parameterProcessor);
        plot.setRenderer(renderer);

//        renderer.setBaseItemLabelGenerator(new CategoryItemLabelGenerator(){
//            public String generateLabel(CategoryDataset dataset, int series, int categories) {
//               //GET LABELS AND PRINT THEM HERE
//                String label = "";
//               return label;
//              }
//
//              public String generateColumnLabel(CategoryDataset dataset, int categories) {
//                  return dataset.getColumnKey(categories).toString();
//              }
//
//              public String generateRowLabel(CategoryDataset dataset, int series) {
//                  return dataset.getRowKey(series).toString();
//              }
//         });
         
        renderer.setBaseItemLabelsVisible(true);
        renderer.setBasePositiveItemLabelPosition(new ItemLabelPosition(ItemLabelAnchor.OUTSIDE9, TextAnchor.CENTER_LEFT));
        renderer.setDrawBarOutline(true);
        renderer.setShadowVisible(true);
        
        renderer.setSeriesShape(0, (Shape) new Rectangle(0,0));
        BarPainter barPainter = new StandardBarPainter();
        renderer.setBarPainter(barPainter);
        renderer.setSeriesPaint(0, Color.blue);
        renderer.setShadowVisible(false);
        DateAxis dateAxis =  (DateAxis) plot.getRangeAxis();
        dateAxis.setRange(plotStartDate, plotEndDate);
        System.out.println(plotStartDate.toString()+", "+plotEndDate.toString());
//        dateAxis.setTickUnit(new DateTickUnit(DateTickUnitType.MINUTE, 2));
        dateAxis.setVerticalTickLabels(true);


        /**
         * @TODO: Timer to refresh the currentEpochTime Marker on the chartPanel
         */
        Date date = new Date();
//        double epoch_time = date.getTime();
        double epoch_time = scheduler.getCurrentEpochTime();
        ValueMarker marker = new ValueMarker(epoch_time, Color.RED, new BasicStroke(2.0f));
        plot.addRangeMarker(marker, Layer.BACKGROUND);

        plot.setRenderer(renderer);       
        
        return chart;
    }

    private JFreeChart chart;
    private IntervalCategoryDataset dataset;
    DanChartMouseListener chartMouseListener = new DanChartMouseListener();
    private String clickedCategory = "";
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton addOperationButton;
    private javax.swing.JButton addTestCasePatientButton;
    private javax.swing.JPanel chartPanel;
    private javax.swing.JButton deleteOperationButton;
    private javax.swing.JButton editOperationButton;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JPanel jPanel2;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JTextArea jTextArea1;
    // End of variables declaration//GEN-END:variables

}
